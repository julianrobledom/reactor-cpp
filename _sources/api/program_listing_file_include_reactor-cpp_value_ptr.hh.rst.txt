
.. _program_listing_file_include_reactor-cpp_value_ptr.hh:

Program Listing for File value_ptr.hh
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_reactor-cpp_value_ptr.hh>` (``include/reactor-cpp/value_ptr.hh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2019 TU Dresden
    * All rights reserved.
    *
    * Authors:
    *   Christian Menard
    */
   
   #ifndef REACTOR_CPP_VALUE_PTR_HH
   #define REACTOR_CPP_VALUE_PTR_HH
   
   #include <memory>
   #include <type_traits>
   
   namespace reactor {
   
   // forward declaration
   template <class T> class ImmutableValuePtr;
   
   template <class T> class MutableValuePtr { // NOLINT
   private:
     std::unique_ptr<T> internal_ptr;
   
     explicit MutableValuePtr(T* value)
         : internal_ptr(value) {}
   
   public:
     constexpr MutableValuePtr()
         : internal_ptr(nullptr) {}
     MutableValuePtr(const MutableValuePtr&) = delete;
     MutableValuePtr(MutableValuePtr&& ptr) noexcept = default;
     explicit constexpr MutableValuePtr(std::nullptr_t)
         : internal_ptr(nullptr) {}
   
     auto operator=(MutableValuePtr&& ptr) noexcept -> MutableValuePtr& {
       this->internal_ptr = std::move(ptr.internal_ptr);
       return *this;
     }
     auto operator=(std::nullptr_t) noexcept -> MutableValuePtr& {
       this->internal_ptr = nullptr;
       return *this;
     }
   
     [[nodiscard]] auto get() const noexcept -> T* { return internal_ptr.get(); }
   
     explicit operator bool() const { return get() == nullptr; }
   
     auto operator*() const -> T& { return *get(); }
     auto operator->() const -> T* { return get(); } // NOLINT
   
     // Give ImmutableValuePtr access to the private constructor. This is required
     // for creating a MutableValuePtr from an ImmutableValuePtr in
     // get_mutable_copy()
     friend class ImmutableValuePtr<T>;
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     // NOLINTNEXTLINE(readability-redundant-declaration)
     template <class U, class... Args> friend auto make_mutable_value(Args&&... args) -> MutableValuePtr<U>;
   };
   
   template <class T> class ImmutableValuePtr { // NOLINT
   public:
     using const_T = typename std::add_const<T>::type;
   
   private:
     std::shared_ptr<T> internal_ptr;
   
     explicit ImmutableValuePtr(T* value)
         : internal_ptr(value) {}
   
   public:
     constexpr ImmutableValuePtr()
         : internal_ptr(nullptr) {}
     ImmutableValuePtr(const ImmutableValuePtr& ptr) = default;
     ImmutableValuePtr(ImmutableValuePtr&& ptr) noexcept = default;
     explicit constexpr ImmutableValuePtr(std::nullptr_t)
         : internal_ptr(nullptr) {}
     explicit ImmutableValuePtr(MutableValuePtr<T>&& ptr)
         : internal_ptr(std::move(ptr.internal_ptr)) {}
   
     auto operator=(std::nullptr_t) -> ImmutableValuePtr& {
       this->internal_ptr = nullptr;
       return *this;
     }
     auto operator=(const ImmutableValuePtr& ptr) -> ImmutableValuePtr& { // NOLINT(cert-oop54-cpp)
       this->internal_ptr = ptr.internal_ptr;
       return *this;
     }
     auto operator=(ImmutableValuePtr&& ptr) noexcept -> ImmutableValuePtr& {
       this->internal_ptr = std::move(ptr.internal_ptr);
       return *this;
     }
   
     [[nodiscard]] auto get() const -> const_T* { return internal_ptr.get(); }
   
     explicit operator bool() const { return get() == nullptr; }
   
     auto operator*() const -> const_T& { return *get(); }
     auto operator->() const -> const_T* { return get(); }
   
     [[nodiscard]] auto get_mutable_copy() const -> MutableValuePtr<T> { return MutableValuePtr<T>(new T(*internal_ptr)); }
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     // NOLINTNEXTLINE(readability-redundant-declaration)
     template <class U, class... Args> friend auto make_immutable_value(Args&&... args) -> ImmutableValuePtr<U>;
   };
   
   template <class T, class... Args> auto make_immutable_value(Args&&... args) -> ImmutableValuePtr<T> {
     return ImmutableValuePtr<T>(new T(std::forward<Args>(args)...));
   }
   
   template <class T, class... Args> auto make_mutable_value(Args&&... args) -> MutableValuePtr<T> {
     return MutableValuePtr<T>(new T(std::forward<Args>(args)...));
   }
   
   // Comparison operators
   
   template <class T, class U>
   auto operator==(const MutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T, class U>
   auto operator==(const ImmutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T, class U>
   auto operator==(const ImmutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T, class U>
   auto operator==(const MutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T> auto operator==(const MutableValuePtr<T>& ptr1, std::nullptr_t) noexcept -> bool {
     return ptr1.get() == nullptr;
   }
   template <class T> auto operator==(std::nullptr_t, const MutableValuePtr<T>& ptr2) noexcept -> bool {
     return ptr2.get() == nullptr;
   }
   template <class T> auto operator==(const ImmutableValuePtr<T>& ptr1, std::nullptr_t) noexcept -> bool {
     return ptr1.get() == nullptr;
   }
   template <class T> auto operator==(std::nullptr_t, const ImmutableValuePtr<T>& ptr1) noexcept -> bool {
     return ptr1.get() == nullptr;
   }
   
   template <class T, class U>
   auto operator!=(const MutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() != ptr2.get();
   }
   
   template <class T, class U>
   auto operator!=(const ImmutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) -> bool {
     return ptr1.get() != ptr2.get();
   }
   template <class T, class U> auto operator!=(const ImmutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) -> bool {
     return ptr1.get() != ptr2.get();
   }
   template <class T, class U> auto operator!=(const MutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) -> bool {
     return ptr1.get() != ptr2.get();
   }
   template <class T> auto operator!=(const MutableValuePtr<T>& ptr1, std::nullptr_t) -> bool {
     return ptr1.get() != nullptr;
   }
   template <class T> auto operator!=(std::nullptr_t, const MutableValuePtr<T>& ptr1) -> bool {
     return ptr1.get() != nullptr;
   }
   template <class T> auto operator!=(const ImmutableValuePtr<T>& ptr1, std::nullptr_t) -> bool {
     return ptr1.get() != nullptr;
   }
   template <class T> auto operator!=(std::nullptr_t, const ImmutableValuePtr<T>& ptr1) -> bool {
     return ptr1.get() != nullptr;
   }
   
   } // namespace reactor
   
   #endif
