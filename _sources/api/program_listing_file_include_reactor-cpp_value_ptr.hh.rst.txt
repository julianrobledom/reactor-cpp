
.. _program_listing_file_include_reactor-cpp_value_ptr.hh:

Program Listing for File value_ptr.hh
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_reactor-cpp_value_ptr.hh>` (``include/reactor-cpp/value_ptr.hh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2019 TU Dresden
    * All rights reserved.
    *
    * Authors:
    *   Christian Menard
    */
   
   #ifndef REACTOR_CPP_VALUE_PTR_HH
   #define REACTOR_CPP_VALUE_PTR_HH
   
   #include <memory>
   #include <type_traits>
   
   namespace reactor {
   
   namespace detail {
   
   template <class T, bool is_scalar> class ImmutableValuePtr {};
   template <class T, bool is_scalar> class MutableValuePtr {};
   
   } // namespace detail
   
   template <class T> using MutableValuePtr = detail::MutableValuePtr<T, std::is_scalar<T>::value>;
   template <class T> using ImmutableValuePtr = detail::ImmutableValuePtr<T, std::is_scalar<T>::value>;
   
   template <class T, class... Args> auto make_immutable_value(Args&&... args) -> ImmutableValuePtr<T> {
     if constexpr (std::is_scalar<T>::value) {
       return ImmutableValuePtr<T>(T(std::forward<Args>(args)...));
     } else {
       return ImmutableValuePtr<T>(std::make_shared<T>(std::forward<Args>(args)...));
     }
   }
   
   template <class T, class... Args> auto make_mutable_value(Args&&... args) -> MutableValuePtr<T> {
     if constexpr (std::is_scalar<T>::value) {
       return MutableValuePtr<T>(T(std::forward<Args>(args)...));
     } else {
       return MutableValuePtr<T>(std::make_unique<T>(std::forward<Args>(args)...));
     }
   }
   
   // Comparison operators
   
   template <class T, class U>
   auto operator==(const MutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T, class U>
   auto operator==(const ImmutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T, class U>
   auto operator==(const ImmutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T, class U>
   auto operator==(const MutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() == ptr2.get();
   }
   template <class T> auto operator==(const MutableValuePtr<T>& ptr1, std::nullptr_t) noexcept -> bool {
     return ptr1.get() == nullptr;
   }
   template <class T> auto operator==(std::nullptr_t, const MutableValuePtr<T>& ptr2) noexcept -> bool {
     return ptr2.get() == nullptr;
   }
   template <class T> auto operator==(const ImmutableValuePtr<T>& ptr1, std::nullptr_t) noexcept -> bool {
     return ptr1.get() == nullptr;
   }
   template <class T> auto operator==(std::nullptr_t, const ImmutableValuePtr<T>& ptr1) noexcept -> bool {
     return ptr1.get() == nullptr;
   }
   
   template <class T, class U>
   auto operator!=(const MutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) noexcept -> bool {
     return ptr1.get() != ptr2.get();
   }
   
   template <class T, class U>
   auto operator!=(const ImmutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) -> bool {
     return ptr1.get() != ptr2.get();
   }
   template <class T, class U> auto operator!=(const ImmutableValuePtr<T>& ptr1, const MutableValuePtr<U>& ptr2) -> bool {
     return ptr1.get() != ptr2.get();
   }
   template <class T, class U> auto operator!=(const MutableValuePtr<T>& ptr1, const ImmutableValuePtr<U>& ptr2) -> bool {
     return ptr1.get() != ptr2.get();
   }
   template <class T> auto operator!=(const MutableValuePtr<T>& ptr1, std::nullptr_t) -> bool {
     return ptr1.get() != nullptr;
   }
   template <class T> auto operator!=(std::nullptr_t, const MutableValuePtr<T>& ptr1) -> bool {
     return ptr1.get() != nullptr;
   }
   template <class T> auto operator!=(const ImmutableValuePtr<T>& ptr1, std::nullptr_t) -> bool {
     return ptr1.get() != nullptr;
   }
   template <class T> auto operator!=(std::nullptr_t, const ImmutableValuePtr<T>& ptr1) -> bool {
     return ptr1.get() != nullptr;
   }
   
   namespace detail {
   
   template <class T> class MutableValuePtr<T, false> {
   private:
     std::unique_ptr<T> internal_ptr;
   
     explicit MutableValuePtr(std::unique_ptr<T>&& value)
         : internal_ptr(std::move(value)) {}
   
   public:
     constexpr MutableValuePtr() = default;
     ~MutableValuePtr() = default;
   
     MutableValuePtr(const MutableValuePtr&) = delete;
   
     MutableValuePtr(MutableValuePtr&& ptr) noexcept = default;
   
     explicit constexpr MutableValuePtr(std::nullptr_t)
         : internal_ptr(nullptr) {}
   
     auto operator=(MutableValuePtr&& ptr) noexcept -> MutableValuePtr& {
       this->internal_ptr = std::move(ptr.internal_ptr);
       return *this;
     }
   
     auto operator=(const MutableValuePtr& ptr) -> MutableValuePtr& = delete;
   
     auto operator=(std::nullptr_t) noexcept -> MutableValuePtr& {
       this->internal_ptr = nullptr;
       return *this;
     }
   
     [[nodiscard]] auto get() const noexcept -> T* { return internal_ptr.get(); }
   
     explicit operator bool() const { return get() == nullptr; }
   
     auto operator*() const -> T& { return *get(); }
     auto operator->() const -> T* { return get(); } // NOLINT
   
     // Give ImmutableValuePtr access to the private constructor. This is required
     // for creating a MutableValuePtr from an ImmutableValuePtr in
     // get_mutable_copy()
     friend class ImmutableValuePtr<T, false>;
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     template <class U, class... Args>
     // NOLINTNEXTLINE(readability-redundant-declaration)
     friend auto reactor::make_mutable_value(Args&&... args) -> reactor::MutableValuePtr<U>;
   };
   
   template <class T> class ImmutableValuePtr<T, false> {
   public:
     using const_T = typename std::add_const<T>::type;
   
   private:
     std::shared_ptr<T> internal_ptr;
   
     explicit ImmutableValuePtr(std::shared_ptr<T>&& value)
         : internal_ptr(std::move(value)) {}
   
   public:
     constexpr ImmutableValuePtr()
         : internal_ptr(nullptr) {}
   
     ~ImmutableValuePtr() = default;
   
     ImmutableValuePtr(const ImmutableValuePtr& ptr) = default;
     ImmutableValuePtr(ImmutableValuePtr&& ptr) noexcept = default;
     explicit constexpr ImmutableValuePtr(std::nullptr_t)
         : internal_ptr(nullptr) {}
     explicit ImmutableValuePtr(MutableValuePtr<T, false>&& ptr)
         : internal_ptr(std::move(ptr.internal_ptr)) {}
   
     auto operator=(std::nullptr_t) -> ImmutableValuePtr& {
       this->internal_ptr = nullptr;
       return *this;
     }
     auto operator=(const ImmutableValuePtr& ptr) -> ImmutableValuePtr& { // NOLINT(cert-oop54-cpp)
       this->internal_ptr = ptr.internal_ptr;
       return *this;
     }
     auto operator=(ImmutableValuePtr&& ptr) noexcept -> ImmutableValuePtr& {
       this->internal_ptr = std::move(ptr.internal_ptr);
       return *this;
     }
   
     [[nodiscard]] auto get() const -> const_T* { return internal_ptr.get(); }
   
     explicit operator bool() const { return get() == nullptr; }
   
     auto operator*() const -> const_T& { return *get(); }
     auto operator->() const -> const_T* { return get(); }
   
     [[nodiscard]] auto get_mutable_copy() const -> MutableValuePtr<T, false> {
       return MutableValuePtr<T, false>(std::make_unique<T>(*internal_ptr));
     }
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     template <class U, class... Args>
     // NOLINTNEXTLINE(readability-redundant-declaration)
     friend auto reactor::make_immutable_value(Args&&... args) -> reactor::ImmutableValuePtr<U>;
   };
   
   template <class T> class MutableValuePtr<T, true> {
   private:
     T value_{};
     bool valid_{false};
   
     explicit MutableValuePtr(const T value)
         : value_{value}
         , valid_{true} {}
   
   public:
     constexpr MutableValuePtr() = default;
     ~MutableValuePtr() = default;
     MutableValuePtr(const MutableValuePtr&) = delete;
     MutableValuePtr(MutableValuePtr&& ptr) noexcept = default;
   
     explicit constexpr MutableValuePtr(std::nullptr_t) {}
   
     auto operator=(MutableValuePtr&& ptr) noexcept -> MutableValuePtr& = default;
     auto operator=(const MutableValuePtr& ptr) -> MutableValuePtr& = delete;
   
     auto operator=(std::nullptr_t) noexcept -> MutableValuePtr& {
       valid_ = false;
       return *this;
     }
   
     [[nodiscard]] auto get() noexcept -> T* { return valid_ ? &value_ : nullptr; }
     [[nodiscard]] auto get() const noexcept -> const T* { return valid_ ? &value_ : nullptr; }
   
     explicit operator bool() const { return valid_; }
   
     auto operator*() -> T& { return value_; }
     auto operator*() const -> const T& { return value_; }
   
     auto operator->() -> T* { return get(); }
     auto operator->() const -> const T* { return get(); }
   
     // Give ImmutableValuePtr access to the private constructor. This is required
     // for creating a MutableValuePtr from an ImmutableValuePtr in
     // get_mutable_copy()
     friend class ImmutableValuePtr<T, true>;
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     template <class U, class... Args>
     // NOLINTNEXTLINE(readability-redundant-declaration)
     friend auto reactor::make_mutable_value(Args&&... args) -> reactor::MutableValuePtr<U>;
   };
   
   template <class T> class ImmutableValuePtr<T, true> {
   public:
     using const_T = typename std::add_const<T>::type;
   
   private:
     T value_{};
     bool valid_{false};
   
     explicit ImmutableValuePtr(T value)
         : value_{value}
         , valid_{true} {}
   
   public:
     constexpr ImmutableValuePtr() = default;
     ~ImmutableValuePtr() = default;
     ImmutableValuePtr(const ImmutableValuePtr& ptr) = default;
     ImmutableValuePtr(ImmutableValuePtr&& ptr) noexcept = default;
   
     explicit constexpr ImmutableValuePtr(std::nullptr_t) {}
     explicit ImmutableValuePtr(MutableValuePtr<T, false>&& ptr)
         : value_(ptr.value_)
         , valid_(ptr.valid_) {}
   
     auto operator=(std::nullptr_t) -> ImmutableValuePtr& {
       this->valid_ = false;
       return *this;
     }
     auto operator=(const ImmutableValuePtr& ptr) -> ImmutableValuePtr& = default;
     auto operator=(ImmutableValuePtr&& ptr) noexcept -> ImmutableValuePtr& = default;
   
     [[nodiscard]] auto get() const -> const_T* { return valid_ ? &value_ : nullptr; }
   
     explicit operator bool() const { return valid_; }
   
     auto operator*() const -> const_T& { return value_; }
     auto operator->() const -> const_T* { return get(); }
   
     [[nodiscard]] auto get_mutable_copy() const -> MutableValuePtr<T, true> { return MutableValuePtr<T, true>(get()); }
   
     // Give the factory function make_mutable_value() access to the private
     // constructor
     template <class U, class... Args>
     // NOLINTNEXTLINE(readability-redundant-declaration)
     friend auto reactor::make_immutable_value(Args&&... args) -> reactor::ImmutableValuePtr<U>;
   };
   
   } // namespace detail
   
   } // namespace reactor
   
   #endif
